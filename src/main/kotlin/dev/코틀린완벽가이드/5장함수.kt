

fun main(){
//    val c: (String) -> Unit = { str -> println("$str c함수이다") }
//    println(b(c))
//    val shifter: (Int) -> (Int) -> Int = {n -> { i -> i+n }}
//    val a = shifter(1)
//    val b = shifter(-1)
//    println(a(10))
//    println(b(9))
//    println(sum1(intArrayOf(1, 2, 3)))
//    println(max(intArrayOf(1, 2, 3)))
//    foreach(intArrayOf(1, 2, 3, 4, 5)){
//        if(it < 2 || it > 3) return
//        println(it)
//    }
    println("123%%")
}
fun b(function: (String) -> Unit) = function("b가 호출한")
fun aggregate(numbers: IntArray, op: (Int, Int) -> Int): Int{
    var result = numbers.firstOrNull()?: throw IllegalArgumentException("Empty Array")
    for (i in 1..numbers.lastIndex) result = op(result, numbers[i])
    return result
}
fun sum1(numbers: IntArray)= aggregate(numbers) { result, op -> result + op }
fun max(numbers: IntArray) = aggregate(numbers) { result, op -> if(op > result) op else result}
inline fun foreach(a: IntArray, action: (Int) -> Unit){
    for (n in a) action(n)
}

/*
    1. 고차함수란 무엇인가?
    함수를 인스턴스 처럼 취급하는 방법
    함수를 패러미터로 넘길 수 있고 결과값으로 반환 받을 수도 있는 방법이다
    코틀린에서는 모든 함수를 고차함수로 사용 가능

    2.람다 함수 식 문법
    패터미터로 넘길 함수를 이름까지 붙일 필요는 없다 - > 람다함수 사용 가능
    람다 함수는 그자체가 고차 함수이기 때문에 일반 변수에 람다식 할당하여 사용가능
    람다식 구성
    변수를 함수처럼 람다식 선언    람다식 매개변수     처리 내용
    사용 가능      자료형
    val lambda: (Int) -> Int = {x: Int, y:Int -> x * y}
    선언 자료형이 명시되어 있으면 매개변수의 자료형 생략가능
    처리내용이 여러줄인경우 마지막 표현식 반환
    자바의 람다식과 다른점

    자바에서는 파이널로만 람다식을 저장할수있다 final로써야한다

    3. 함수 타입이란 무엇인가 코틀린 함수 타입과 자바 함수형 인터페이스 차이점
    람다나 익명함수나 함수타입의 객체를 같은 함수 타입으로 묵어서 사용할수 있게하는것
    자바 함수형 인터페이스와 차이점
    자바에서는 함수형 인터페이스로만 만들어서 함수타입을 사용할수있지만
    코틀린에서는 변수나 파라미터에 넣어서 사용할수있다

    코틀린은 람다가 형이다
    자바에서는 람다가 형이 아니라 인터페이스나 클래스다
    자바에서 람다는 편의문법이고 코틀린에서 람다는 형이다
    입장이 반대다 자바는 컴파일하면 람다가 인터페이스나 이딴걸로 바뀜
    (람다팩토리 참고)

    4. 수신객체가 있는 함수 타입과 없는 함수 타입을 비교 설명
    수신객체가 있는 함수타입은 this를 사용해 객체에 접근 가능하고
    수신객체가 있는 함수타입은 확장형태나 비확장 형태 어느쪽으로든 호출 할 수 있지만 수신객체가 없으면 비확장 형태로만 호출가능

    수신객체의 장점 람다 내에서 this를 사용할 수 있어서 좋다
    함수를 접할때 쉐도잉의 문제가 발생한다(변수나 함수의 이름이 중복될때)
    쉐도우를 얼마나 심각하게 생각하나
    쉐도우 블록킹(바깥쪽을 가리는 방법)만이 의미가 있다 나머지는 쓰레기 에러가나면 찾을수가 없다 짠놈도 몰라

    .문법은 컨텍스트다
    확장함수를 쓰는 이점 this.을 암묵적으로 사용하지 않을수있지만 this 쉐도잉이 생길 가능성이 있다
    회사에서는 확장 함수를 쓰지않고 인자로 받게 쓴다
    내장을 까면서까지 확장 함수를 쓸 필요는 없다

    5. 람다와 익명 함수의 차이는 무엇인가 람다를 쓰는것 보다 임명함수를 쓰는것이 더 좋은때가 언제인지
    람다와 익명 함수의 차이는 return을 쓸 수 있는가 없는가

    변수의 타입은 타입추론을 사용하고 리턴타입만 지정하고 싶을때
    익명함수는 변수 할당이 안된다

    익명함수가 인라인이 아닐때 내부에서 return을 사용할 수 있다
    즉시 함수의 인자로 넘기는 람다를 넘길시 익명 함수로 넘기면 리턴 불가
    익명함수도 레이블 리턴이 가능하다

    그냥리턴 사용시 람다는 리턴불가 익명함수는 자기 구역 반환
    라벨리턴 사용시 람다는 자기구역 반환 익명함수는 외부 구역 반환
    익명함수는 거의 람다이다 문법의 차이만 있을뿐

    6. 인라인 함수의 장단점을 설명하라 인라인 함수에는 어떤 제약이 있는가
    함수를 호출하는 대신 함수의 바이트코드가 함수를 호출하는 위치에 들어가 함수 호출의 오버헤드를 제거하지만
    모든 부분에 바이트 코드가 들어가기 때문에 긴함수를 인라인 으로 사용하는건 좋지 않다

    인라인 함수 사용시 파라미터에 noinline crossinline같은 키워드를 사용했을때 return의 동작이 어떻게 바뀌는지 이해하지 못하고 쓸 경우
    예상했던 함수의 동작과 다르게 동작할 수 있다

    7. 호출 가능 참조란 무엇인가 호출가능 참조의 여러 가지 형태를 설명하라 자바 메서드 참조와 비교
    메서드 참조는 람다식을 더 간단히 한것 사용법 -> 클래스이름::메서드이름
    람다를 넘길 때 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 갖고 있다면, 간단하게 이중 콜론(::) 으로 사용할 수 있습니다

    8. 람다와 익명 함수 안에서 return이 어떻게 작동하는지 설명, 한정시킨 return문이란 무엇인지설명
    익명 함수는 일반 함수처럽 리턴이 동작한다(익명함수 자체가 값을 리턴)
    람다보다 장황하다 특정 예외를 제외하면 람다가 좋다

    람다는 리턴값이 있더라도 return 키워드를 가질수 없고 이게 익명함수와의 차이점이다
    익명 함수는 리턴값이 있을경우 반드시 return 키워드를 사용해야 한다

    람다안에서 return을 사용하는경우 람다를 빠져나갈지 외부함수를 빠져나갈지 기준이 애매모호하기 때문에 에러를 내는데
    리턴을 사용하게 하기 위해서 코틀린은 라벨리턴과 비지역 리턴이라는 예외를 만들었다
    라벨리턴을 하면 동작중인 람다를 스킵할수있다 비지역 리턴을 사용하면 람다를 선언한 곳 바깥으로 나갈 수 있다

    현재 람다에서 나가고 싶다면 라벨리턴을 사용하면된다 label@  return@label 함수 이름같은 암시적인 라벨도 사용가능

    9. 함수 타입 파라미터의 디폴트 인라인 모드와 noinline, crossinline 비교
    함수파라미터도 인라인이면 파라미터도 인라인 되어 함수 본문이 그대로 삽입 됨
    모든 람다식에 inline을 쓰고 싶지 않을 경우 noinline키워드를 붙여 인라인 방지
    어떤곳은 인라인이되고 어떤곳은 인라인이 안된다 비지역 반환 현상을 방지하기 위해 crossinline 키워드 사용

    인라인은 인라인 연쇄가 발생한다
    인라인 함수 안에서 변수에 인라인된 멤버를 할당할 수 없다

    바깥이 인라인이 아니면 안에서 인라인을 아무리 써봐야 인라인 되지 않는다(함수 객체로 바뀜)
    람다가 여러개일 경우만 성립한다

    10. 확장 함수를 정의하는 방법, 확장 함수는 확장이 적용된 함수를 변경하는가?
    수신객체의 클래스이름을 표시하고 점을 추가한다음 함수이름을 정의한다

    11. 동반 객체 확장을 사용하는 방법 설명
    동반객체가 존재하는 경우 동반객체 이름을 사용해 확장함수 호출가능 확장프로퍼티도 마찬가지
    동반객체 확장함수는 상태를 다 퍼블릭으로만 선언해야한다
    private을 갖는 확장을 하고싶다면 동반객체에 인터페이스를 꽃아라

    12. 확장 프로퍼티에는 어떤 제약이 있는가
    확장 프로퍼티는 뒷받침하는 필드를 사용할 수 없다(초기화 불가, 접근자 안에서 fiedl사용불가, lateinit불가)
    명시적인 게터를 정의해야하고 가변일경우 세터도 명시해야함
    무엇보다 this의 속성이 퍼블릭 이여야 한다
    확장 프로퍼티 val은 읽기전용인데 set()을써버리면 은닉이 깨져버린다

    확장 프로퍼티는 확장 함수와 마찬가지로, 직접 수정할 수 없는 클래스에 변수를 추가해주고 싶을 때 쓸 수 있다.
    단, 기존 클래스 내에 직접 값을 저장할 수는 없으므로 getter property로만 설정할 수 있다.

    13. 여러가지 형태의 this식을 설명하라 한정시킨 this를 언제 어떻게 사용하는가

    14. 클래스 내부에서 확장 함수를 선언하는 경우 주의해야 할 점
    컴파일러는 멤버함수를 우선적으로 선택
    확장 함수를 먼저 정의하고 똑같은 멤버를 클래스에 추가하게 될경우 먼저 정의한 확장함수를 사용한곳에 의미가 달라진다
    쓰지말자 이건...인자를 줄일수 있다는것에 장점이 있지만 무슨인자가 들어오는 함수인지 모르기때문에 가독성 저하

    15. 영역 함수란 무엇인가 어떤일을 처리할 때 어떤 영역 함수를 사용할지 판단하는 기준이 무엇인지 설명하라

    인스턴스의 속성이나 함수를 깔끔하게 불러 쓸수있다 코드의 가독성 향상
    apply 인스턴스 생성후 변수 담기전 초기화할때  참조연산자를 사용하지 않아도 된다
    run 스코프안에서 참조연산자를 사용하지 않아도 되지만 람다 함수처럼 인스턴스 대신 마지막구문만 반환한다 (이미 인스턴스가 만들어진 후에 함수나 속성을 스코프내에서 사용할때)
    run은 컨택스트 없이 사용가능 수신객체런과 함수런이 있다
    with 런과동일한 기능을 하지만 인스턴스를 참조연산자 대신 패러미터로 받아 사용한다
    also 처리가 끝나면 인스턴스 반환 마치 패러미터로 인스턴스를 넘긴거처럼 it을통해 사용(같은 이름의 변수나 함수가 스코프 밖에 중복되어있는경우에 이를 방지하기 위해)
    let 처리가 끝나면 최종값 반환 마치 패러미터로 인스턴스를 넘긴거처럼 it을통해(같은 이름의 변수나 함수가 스코프 밖에 중복되어있는경우에 이를 방지하기 위해)

    run, let 람다의 리턴값이 결과값이 된다 차이점은 this 사용 it 사용
    apply, also 받았던 수신객체를 리턴 차이점은 this 사용 it 사용
    쉐도잉 혐오자는 let, also 쓰는데 걍이거쓰자 맘편하게
*/