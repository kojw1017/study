package 코틀린완벽가이드

/*
    129P
    1. 식이 본문인 함수란 무엇인가, 블록이 본문인 함수 대신 식이 본문인 함수를 쓰면 어떤 경우에 좋은가
    일반적인 식의 종류 : 값식, 연산식, 호출식
    코틀린은 최종적으로 값만 나오면 식으로봄 따라서 값만 나오면 그안에 문을 엄청나게 사용가능
    ex) val a = if(true) 3 else 4
    식이 본문인 함수 (반환타입 추론가능 한줄로 읽기 쉽다)
    fun a() = true
    블록이 본문인 함수
    fun a(): Boolean {
        return true
    }
    반환타입 명시적으로 했을때: 반환타입이 명확하기때문에 본문을 잘못 작성 하기 불가능, 가장 근접한 부모형 사용가능
    반환타입 암시적으로 했을때: 편하다, 본문의 반환타입을 컴파일러에게 물어봐서 잘짜고 있는지 확인가능, 컴파일 속도 느려짐

    가독성을 위해 한줄로 끝나면 식이 본문인 함수 사용
    그렇지 않을경우 블록이 본문인 함수 사용

    2. 디폴트 파라미터와 함수 오버로딩 중 어느 쪽을 써야 할지 어떻게 결정하는가
    인자의 타입이 다를경우에만 오버로딩을 사용하고
    일반적으로는 디폴트 파라미터를 사용하는게 좋다

    3. 이름 붙은 인자를 사용할 경우의 장단점
    장점: 디폴트 파라미터가 있을경우 넣고싶은 인자만 이름붙여서 사용 가능
    단점: 함수 인자를 넣을때 어짜피 인레이 힌트가 있어서 해당 인자가 뭔지 알려주기 때문에
    의도 없이 그냥 이름 붙은 인자를 사용하면 오히려 헷갈릴 수 있다

    코틀린 람다의 경우 마지막 인자가 람다인 경우 블록으로 사용 가능
    ex) fun a(vararg a: Int, block: ()->Unit = {}){}
        a(1, 2, 3){}

    4. 인자 개수가 가변적인 함수를 정의하는 방법은 무엇인가 코틀린과 자바에서 vararg 함수는 어떻게 다른가
    정의 -> fun printSorted(vararg items: Int){}
    사용 -> printSorted(1, 2, 3, 4, 5)

    배열을 가변인자로 넘길때 스프레드 연산자 *사용
    val a = intArrayOf(1, 2, 3, 4, 5)
    printSorted(*a)

    스프레드는 배열을 얕은 복사한다 내부 참조가 복사되기 때문에 유의해라

    타입이 같다면 이딴식으로도 사용가능
    printSorted(1, 2, 3, 4, 5, *intArrayOf(1, 2, 3))

    vararg인자를 맨뒤로 보내는게 좋은 코딩 스타일이다

    이름 붙은 인자 사용 불가능 하지만 스프레드 붙은거는 가능하다
    printSorted(item = *intArrayOf(1, 2, 3))

    vararg 파라미터가 있는 함수는
    동일한 타입의 파라미터 수가 고정돼 있는 함수보다
    덜 구체적인 함수로 간주된다
    예를 들어 다음과 같이 인자가 세 개 있을 때 컴파일러는 2번 함수를 선택한다.
    fun printSorted(vararg items: Int) { } // 1
    fun printSorted(a: Int, b: Int, c: Int) { } // 2

    5. Unit과 Nothing 타입을 어디에 사용하는가 이들의 자바의 void와 비교해 설명하라 Nothing이나 Unit이 타입인 함수를
    정의해 사용할 수 있는가

    7. return 문을 사용하지 않는 함수를 정의할 수 있는가?
    fun a() = true
    fun a() = if(true) 1 else 2
    fun a() = when(a){
        type1 -> 1
        type2 -> 2
        else -> 3
    }
    val a = { a: String -> 1 }

    8. 지역 함수란 무엇인가? 이런 함수를 자바에서는 어떻게 흉내 낼 수 있을까?
    jvm은 지역함수를 람다로 변환해서 흉내냄

    람다와 일반함수 언제사용하다
    제어 흐름이 없다면 람다 반대면 일반함수

    9. 공개(public)와 비공개(private) 최상위 함수는 어떤 차이가 있는가?
    public internal protected private
    자바 : 패키지 가시성
    코틀린 : 파일 가시성

    10. 패키지를 사용해 코드를 어떻게 여러 그룹으로 나눌 수 있는가? 자바와 코틀린 패키지의 가장
    핵심적인 차이는 무엇인지 설명하라.

    c언어 - 모듈에 대한 참조가 물리적인 파일의 위치로 결정
    include 파일의 경로

    자바 - 어떤 물리적인 위치에 있어도 컴파일 시작 포인트로부터 계산되는 폴더의 경로만 일치하면 참조가능
    병행 패키지 a/b/c/a.java 이거만 일치하면 노상관
    c:/project/src/a/b/c/a.java
    d:/project/src/a/b/c/a.java

    코틀린 - 그냥다 읽어버린다 폴더는 장식일뿐 코드의 패키지 선언에 있는 문자열로 패키지 인식

    13. when 문을 처리하는 알고리즘을 설명하라. 자바 switch와 코틀린 when은 어떤 차이가 있는가?
    when{ 순차적 처리
        a ->
        b ->
        c ->
    }
    when(v){ 병렬 최적화 가능성 있음(건너뛰기 가능)
        a ->
        b ->
        c ->
    }

    14. 자바 for (int i = 0; i< 100; i++)와 같이 수를 세는 루프를 코틀린에서는 어떻게 구현하는가?
    코틀린은 2단계 컴파일함
    1. 코틀린 바이트 코드
    2. 플랫폼용으로 번역

    1. 코틀린에서는 객체였지만
    2. 플랫폼 코드에서는 값으로 번역 가능
    장점: 객체 컨텍스트 사용해 편하고 컴파일될때 최적화된 코드로 번역되어서 속도최적화도 된다

    15. 코틀린이 제공하는 루프 문에는 어떤 것이 있는가? while과 do...while의 차이는 무엇인가?
    코틀린 for 루프를 사용해야 하는 이유는 무엇인가?

    while은 바깥 컨텍스트를 쓸수 밖에 없다
    얼마나 반복할지 while이 일어나기 전에 예상 가능

    바깥에서 얼마나 반복할지 모르겠다
    do while 일단 굴려보니 얼마나 반복할지 알겠다

    for루프를 언제 사용하나 -> 얼마나 반복될지 알고있다면
    while은 언제 사용하나 -> 바디가 루프 계획에 영향을 미치는 동적 계획이다 (얼마나 반복될지 예상가능)
    do while은 언제 사용하나 -> 바디가 루프 계획에 영향을 미치는 동적 계획이다 (얼마나 반복될지 예상불가)
 */
