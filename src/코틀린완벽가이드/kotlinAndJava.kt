package 코틀린완벽가이드

import java.math.BigInteger

class CartItem(data: Map<String, Any>){
    val title: String by data
    val price: String by data
    val qty: String by data
}
fun main(){
    println("...!@BaT#*..y.abcd1efghijklm".toLowerCase()
        .filter { it.isLowerCase() || it.isDigit() || it == '-' || it == '_' || it == '.'  }
        .replace("[.]*[.]".toRegex(), ".")
        .removePrefix(".").removeSuffix(".")
        .let { if (it.isEmpty()) "a" else it }
        .let { if (it.length > 15) it.substring(0 until 15) else it }.removeSuffix(".")
        .let {
            if (it.length <= 2)
                StringBuilder(it).run {
                    while (length < 3) append(it.last())
                    toString()
                }
            else it }
    )
    fun Int.toBigInt():BigInteger? = BigInteger.valueOf(toLong())
    var num = 123.toBigInt()

    val item = CartItem(mapOf(
        "title" to "Laptop",
        "price" to "Laptop",
        "quantity" to "Laptop"
    ))

}

/*
    자바에서 코틀린 코드를 쓰는건 미친짓이다
    @Jvm Annotation은 거의 쓰는거 없다 예외적인 경우 빼고
    1. 합성 프로퍼티란 무엇인가, 자바 접근자 메서드를 코틀린에서 사용할 때 적용되는 규칙
    자바에서 게터 세터를 쓸수있게 만드는 것 관습에 따라 코드를 작성해야 한다
    - 게터는 파라미터가 없는 메서드여야 하며, 메서드 이름이 get으로 시작해야 한다.
    - is로 시작하는 게터는 코틀린에서도 이름이 일치한다.
    - 세터는 파라미터가 하나만 있는 메서드여야 하며, 메서드 이름이 set으로 시작해야 한다.

    2. 플랫폼 타입이란 무엇인가, 코틀린이 지원하는 플랫폼 타입의 종류를 설명
    자바는 널이 될 수 있는 타입과 널이 될 수 없는 타입이 구분이 없기 때문에, 자바 코드에서 코틀린 코드로 변형할 때, 플랫폼 타입이라는 걸 사용한다.
    이것은 널이 될 수 있는 타입이기도 하고 널이 될 수 없는 타입이기도 하다.
    널이 될 수 없는 문맥에서 플랫폼 타입을 사용할 경우, NullPointerException이 발생할 수도 있다.

    반환타입을 명시적으로 지정하면 널이 될 수 없는 타입으로 지정할 수 있다

    플랫폼 타입을 notNull로 쓰는 경우가 많다
    자바에서 가져올 경우 무게가 큰 코드를 가져오는게 아닌이상 타입을 확정짓고 넘어오기 때문

    3. 자바 코드의 널 가능성 애너테이션이 코틀린 타입에 어떤 영향을 미치는가
    널 가능성 애너테이션을 통해 인텔리제이같은 개발 환경이 경고해준다.
    자바 코드는 원래 널이 될 수 있는 타입과, 널이 될 수 없는 타입이 구분이 없지만,
    해당 애너테이션을 통해 코틀린에서 널이 될 수 있거나 널이 될 수 없는 타입 중 하나로 정해진다.

    4. 코틀린 타입이 자바 타입으로 매핑되는 방식과, 자바 타입이 코틀린 타입으로 매핑되는 방식 설명
    코틀린 타입의 값은 값의 사용되는 방식에 따라 JVM원시 타입이거나 이에 상응하는 박싱 타입이다다
    자바의 원시 타입은 코틀린의 내장 타입에 해당하며 java.util.List 타입은 (Mutable)List에 해당한다

    **코틀린 컴파일러는 JVM 플랫폼에서 실행되도록 컴파일하는 경우,
    ** 자바 코드에 선언된 내용을 코틀린 코드에서 사용하거나 코틀린 코드에 선언된 타입을 자바 코드에서 사용할 때
    **서로 상응하는 타입을 상호 변환해준다.**
    자바 원시 타입이나 원시 타입에 상응하는 박싱 타입은 코틀린의 기본타입에 대응한다.
    JVM에서 기본 코틀린 타입의 값은 값이 사용되는 방식에 따라 JVM 원시 타입이거나 원시 타입에 상응하는 박싱 타입인다.

    코틀린의 정책 -> 프리미티브가 없다
    무조건 박스형으로 표현하면
    컴파일러가 박싱 상황이 없는 변수는 프리미티브로
    박싱 상황이 있는 변수는 박스형으로 처리

    제네릭은 무조건 객체 타입만 가능 박스형밖에 불가능 하다 int -> Integer

    5. 코틀린의 SAM 변환과 SAM 생성자를 설명하라, 코틀린의 함수형 인터페이스 설명
    추상 메서드가 하나뿐인 자바 인터페이스가 있다면 어느 메소드를 대체할지 알기 때문에 람다 사용 가능
    적절한 변환을 찾지 못할때는 대상 타입을 지정해 변환을 명시한다

    코틀린은 함수타입을 사용할 수 있어 SAM변환이 불필요하지만 사용하고 싶다면
    인터페이스 앞에 fun키워드를 붙여 사용하면 되고 이 인터페이스의 인스턴스 대신 람다 전달 가능


    6. 코틀린 프로퍼티를 자바 코드에서 어떻게 접근할 수 있나
    접근자 메소드를 통해 접근 가능
    is로시작하는 프로퍼티의 경우 게터는 프로퍼티 이름을 그대로 사용하고 세터는 is대신 set을 사용한다

    7. 자바 코드 쪽에서 코틀린 프로퍼티를 뒷받침하는 필드에 접근할 수 있는 경우는 언제인지
    jvmField 에너테이션을 코틀린 코드에서 사용해주면 자바 코드에서 필드 접근 가능
    단순한 게터 세터 사용시에만 가능하고 상속불가하다

    8. 파일 퍼사드란 무엇인가, 코틀린 최상위 함수와 프로퍼티를 자바에서 사용하는 방법 설명
    코틀린에서는 최상위 선언을 자주 사용하는데, 자바에서는 모든 메서드가 어떤 클래스에 속해야하기 때문에, 자동으로 생성되는 클래스
    기본적으로 소스코드 이름 뒤에 Kt를 덧붙인 이름이 된다.

    퍼사드 클래스가 생성되고, 퍼사드 클래스에 생성된 메서드가 정적 메서드이므로,
    자바 코드에서 최상위 메서드에 접근할 때 퍼사드 클래스를 인스턴스화 할 필요 없이 바로 사용할 수 있다.


    9. 여러 코틀린 파일을 한 파사드 클래스로 합치는 방법
    @JvmMultifileClass라는 애너테이션을 붙이고 @JvmName 으로 클래스 이름을 지정해야 한다.
    그러면 코틀린 컴파일러가 자동으로 파사드 클래스 이름이 같은 파일들의 선언을 한데 모아준다.

    10. @JvmName 에너테이션 사용법 설명
    1)`@JvmName` 어노테이션을 통해 퍼사드 클래스 이름을 지정할 수 있다.** 해당 어노테이션은 파일 수준이고 사용할 때 `@file:JvmName(”클래스이름”)`
    자바 클라이언트는 어노테이션에서 정의한 이름을 통해, 이 파일에 선언된 최상위 함수와 프로퍼티에 접근할 수 있다.`MyUtil.getFullName()`

    2)함수에 붙여 시그니처 충돌을 막을 수 있다.
    예를 들어, 코틀린의 fullName이라는 필드의 게터와 getFullName()가 존재한다면, 컴파일 오류가 발생한다.
    JVM상에서 똑같은 시그니처의 메서드를 만들어내기 때문이다.
    이때 `@JvmName` 을 붙이면 자바에서는 해당 이름으로 함수를 호출할 수 있다.


    11. 코틀린 객체 선언의 인스턴스가 자바 코드에 어떻게 노출되는지
    정적인 INSTANCE 필드가 있는 일반적인 클래스로 컴파일된다.

    12. 코틀린 객체 멤버를 자바에서 정적 멤버로 접근할 수 있게 하려면 어떻게 해야 하는지
    @JvmStatic 에너테이션 사용해서 구체적인 인스턴스 지정하지 않아도 함수나 프로퍼티 접근 가능

    13. @JvmOverloads 애너테이션은 어떤 효과가 있는가
    디폴트 값이라는 개념이 없는 자바에서 함수 호출시 코틀린과 비슷하게 사용하기위해 @JvmOverloads를 쓴다
    코틀린 함수의 디폴트값으로 생길 수 있는 경우의 수에 맞게 오버로딩 함수롤 만들어준다
    오버로딩된 함수는 컴파일된 바이너리상에만 존재한다

    14. 코틀린 함수에서 발생할 수 있는 검증 오류를 어떻게 기술할 수 있는가
    @Throws 애너테이션을 사용해 예외 클래스를 지정하는 것이다
 */